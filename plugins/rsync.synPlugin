# Help: RSYNC
function syn_plugin_rsync_help() {
	printf "Synchronise files from one location to another using rsync

Uses a new-line separated list, with key/values separated by '='. Note no trailing slash.

Relative paths will be prepended by the local root from either \$config[env/rsync/root]
or the deepest location of a .syn from the current directory up to the root.

--------------------------------------------------------------------------------

CONFIG

[root]: Path to project root (optional base for relative paths)
dirs: Directories to sync (new-line string)
_ssh: SSH string for the server where the dirs are located
_flags: Replace the default rsync flags with your own
_flags+: Append your own flags to the default
_tunnel: SSH string for a separate server to tunnel through

--------------------------------------------------------------------------------

CONFIG EXAMPLE

config[live/rsync/root]=/path/to/project/root
config[live/rsync/_ssh]=deploy@livehost
config[live/rsync/_flags]=-aclru --progress
config[live/rsync/_flags+]=\"--chown=www-data:www-data --rsync-path=\\\\\"sudo rsync\\\\\"\"
config[live/rsync/_tunnel]=user@host.with.access.to.live
config[live/rsync/dirs]=\"
    uploads=~/path/to/dir
    configs=/root/based/path
\"
"
}

# rsync plugin defaults
config[_rsync_flags]="-acEhlrtuz --progress --no-motd"
# a = archive
# c = checksum
# E = preserve executability
# h = human readable numbers
# l = symlinks as symlinks
# r = recursive
# u = skip newer files
# z = compress for transfer
# p = preserve permissions
# v = verbose


# Flags
flags[rsync-dryrun]=false
flags_help[rsync-dryrun]="RSYNC: Show anticipated changed without actually doing them"

# Vars
vars[rsync-only]=""
vars_help[rsync-only]="RSYNC: Specify dirs to process and ignore others (comma separated)"


# Show dirs
function syn_cmd_rsync-dirs() {
	printf "RSYNC dirs\n"

	local envs=${environments[*]}
	if [[ "$src" || "$dst" ]]; then
		envs=("$src" "$dst")
	fi
	for e in ${envs[*]}; do
		local rsync_dirs=""
		for x in $(printf "${vars[only][@]}" | sed -e 's/,/ /'); do
			if [[ "$x" == "rsync" ]]; then
				for d in ${config[$e/$x/dirs]}; do
					rsync_dirs+="\n  ${d}"
				done
			fi
		done
		if [[ ! "${rsync_dirs}" ]]; then
			rsync_dirs="\n  <none>"
		fi
		printf "\n$(_ bold)%s$(_ reset)${rsync_dirs}\n" $e
	done
}
function syn_cmd_rsync-dirs_help() {
	printf "Show available dirs for src, dst, or all environments"
}


# Plugin: RSYNC
function syn_plugin_rsync() {
	local config_key=$1
	local -A src_paths
	local -A dst_paths

	# Defaults
	: ${config[$dst/$config_key/_flags]:=${config[_rsync_flags]}}

	# Dry run?
	local dryrun_triggered_by=""
	# Has configuration triggered --dry-run?
	local flags_array=(${config[$dst/$config_key/_flags]})
	local flags_array_extra=(${config[$dst/$config_key/_flags+]})
	if ${flags[rsync-dryrun]}; then
		config[$dst/$config_key/_flags+]="${config[$dst/$config_key/_flags+]} --dry-run"
		dryrun_triggered_by="\"--rsync-dryrun\" CLI flag"
	elif in_array "--dry-run" flags_array_extra; then
		dryrun_triggered_by="\"--dry-run\" in \$config[$dst/$config_key/_flags+]"
	elif in_array "--dry-run" flags_array; then
		dryrun_triggered_by="\"--dry-run\" in \$config[$dst/$config_key/_flags]"
	fi
	if [[ "$dryrun_triggered_by" ]]; then
		printf "$(_ bg_yellow)\n\tRSYNC DRY RUN: Actions will be simulated but not executed\n\tTriggered by ${dryrun_triggered_by}\n$(_ reset)\n\n"
	fi

	# Limit as per parameters
	local onlydirs=""
	if [[ "${vars[rsync-only]}" ]]; then
		onlydirs=(${vars[rsync-only]//,/ })
	fi

	# Loop the environments and normalise the paths into two arrays

	# Source
	local cnt=0
	for file in ${config[$src/$config_key/dirs]}; do
		(( cnt++ ))
		local pathinfo=(${file//=/ })
		if [[ "${pathinfo[1]}" ]]; then
			if [[ -z $onlydirs ]] || in_array "${pathinfo[0]}" onlydirs; then
				src_paths["${pathinfo[0]}"]="${pathinfo[1]}"
			fi
		else
			src_paths["$cnt"]="${pathinfo[0]}"
		fi
	done
	local src_ssh=""
	if [[ "${config[${src}/${config_key}/_ssh]}" ]]; then
		src_ssh="${config[${src}/${config_key}/_ssh]}:"
	fi

	# Destination
	cnt=0
	for file in ${config[$dst/$config_key/dirs]}; do
		(( cnt++ ))
		local pathinfo=(${file//=/ })
		if [[ "${pathinfo[1]}" ]]; then
			if [[ -z $onlydirs ]] || in_array "${pathinfo[0]}" onlydirs; then
				dst_paths["${pathinfo[0]}"]="${pathinfo[1]}"
			fi
		else
			dst_paths["$cnt"]="${pathinfo[0]}"
		fi
	done
	local dst_ssh=""
	if [[ "${config[${dst}/${config_key}/_ssh]}" ]]; then
		dst_ssh="${config[${dst}/${config_key}/_ssh]}:"
		src_ssh="" # Can't use two remotes
	fi

	# Loop it and create the commands
	for i in "${!src_paths[@]}"; do
		if [[ "${dst_paths[$i]}" ]]; then
			local pattern="^(~|/|./|../)"
			local src_path="$(printf "${src_paths[$i]}" | sed -e 's/\*$//')"
			if [[ ( ( "${config[${src}/${config_key}/root]}" ) || ( $local_root && ! "${config[${src}/${config_key}/_ssh]}" ) ) && ! $src_path =~ $pattern ]]; then
				if [[ "${config[${src}/${config_key}/root]}" ]]; then
					src_path="${config[${src}/${config_key}/root]}/${src_path}"
				else
					src_path="${local_root}/${src_path}"
				fi
			fi
			local dst_path="$(printf "${dst_paths[$i]}" | sed -e 's/\*$//')"
			if [[ ( ( "${config[${dst}/${config_key}/root]}" ) || ( $local_root && ! "${config[${dst}/${config_key}/_ssh]}" ) ) && ! $dst_path =~ $pattern ]]; then
				if [[ "${config[${dst}/${config_key}/root]}" ]]; then
					dst_path="${config[${dst}/${config_key}/root]}/${dst_path}"
				else
					dst_path="${local_root}/${dst_path}"
				fi
			fi

			# Are we routing through an SSH tunnel?
			local tunnel=""
			if [[ "${config[${src}/${config_key}/_tunnel]}" && "${config[${dst}/${config_key}/_tunnel]}" ]]; then
				syn_error "Sorry, you can't use _tunnel for both source and destination."
			fi
			if [[ "${config[${src}/${config_key}/_tunnel]}" ]]; then
				tunnel="-e 'ssh -A ${config[${src}/${config_key}/_tunnel]} ssh'"
			elif [[ "${config[${dst}/${config_key}/_tunnel]}" ]]; then
				tunnel="-e 'ssh -A ${config[${dst}/${config_key}/_tunnel]} ssh'"
			fi

			local rsync_cmd="rsync \
				${config[${dst}/${config_key}/_flags]} ${config[${dst}/${config_key}/_flags+]} \
				${tunnel} \
				${src_ssh}${src_path}/ \
				${dst_ssh}${dst_path}
			"

			# Should src be over SSH?
			if [[ "${config[${src}/${config_key}/_ssh]}" && "${config[${dst}/${config_key}/_ssh]}" ]]; then
				rsync_cmd=$(syn_ssh_wrap "${config[${src}/${config_key}/_ssh]}" "${rsync_cmd}")
			fi
			if ${flags[dryrun]}; then
				# sed 's/[\t ]\+/ /g' # even cleaner but will break if paths have double spaces
				printf "%s\n" "$rsync_cmd" | sed 's/\t\+/ /g'
			else
				eval $rsync_cmd
			fi
		fi
	done
}
