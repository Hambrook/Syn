#!/bin/bash

# SYN
#
# Easily synchronise website content (database and asset files) between environments
#
# @version    0.2
# @author     Rick Hambrook <rick@rickhambrook.com>
# @copyright  Copyright (c) 2016, Rick Hambrook
# @license    http://opensource.org/licenses/GPL-3.0  GNU Public License


# TODO
# [X] Add rsync ssh proxy (-e "ssh -A root@proxy ssh")
# [X] Fix rsync flags not being applied
# [X] Update plugin docs with new naming scheme, and flag/var support
# [ ] Use centralised config file for paths and setting, docker/docker-machine (location optionally configurable via env var)
# [ ] Add boot2docker support
# [ ] Add pre-flight validation checks for each plugin
# [ ] Add core validation functions for use by plugins
# [ ]   - ssh connection works (maybe, might cause too many connections)
# [ ]   - docker container exists
# [ ]   - docker container on ssh host is accessible and exists
# [ ] Add timing report
# [ ] Add colours to output
# [ ] Check all quotes and escape sequences
# [ ] See if there is an easier to way merge defaults with supplied values
# [ ] RSYNC: Find a better way to define file paths
# [ ] Maybe load a single location as global config, maybe ~/.syn/config
# [ ] Add shorthand parameters?
# [ ] Enable notify-send?
# [ ] Enable dumping of sample config from each plugin?
# [ ] Clean up logic around mysql only/skip/stru
# [ ] RSYNC: Add excludes list
# [X] Enable specifying a file to load (--file)
# [X]   - Search in specified location for RSYNC (eg store all syn RSYNC in one location, specified by an env var)
# [ ] Add more error checking
# [X]   - Check that both environments exist
# [X]   - Require two environments
# [X]   - Check a plugin exists before attempting to use it
# [X]   - Only sync file locations with matching keys
# [X] RSYNC: add manual and auto root
# [X] Rename builtin plugins to "mysql" and "rsync" instead of "db" and "files"
# [X] Add optional docker layer
# [X] Move flags, vars, and commands to being dynamic with dynamic help so that plugins can add them
# [X] Add default path for use with the --file parameter
# [X] Automatically list actions to be taken for each sync
# [X] Enable listing of environments (--envs)?
# [X] Enable listing of plugins (--plugins)?
# [X] Load from multiple RSYNC, eg in repo, locally and globally
# [X] Support loading extra action plugins from an environmental path
# [X] Help system
# [X]   - Dynamically list action plugins
# [X]   - Dynamically list action plugin help
# [X] MySQL: Allow skipping of tables
# [X] MySQL: Allow structure-only table copies
# [X] MySQL: Allow toggling of using SSH for MySQL connections
# [X] Prompt/warn before pushing to prod/live or if _allow is set to "warn"
# [X] Disallow if _allow is set to false

_SYN_VERSION=0.2
_SYN_AUTHOR="Rick Hambrook"
_SYN_WEBSITE="http://www.rickhambrook.com"

# Initial settings
declare cmd="sync"
declare src
declare dst
declare config_cnt
declare plugin_cnt
declare local_root=""
declare -A actions
declare -A commands
declare -A environments
declare -A plugins
declare exec_path="${BASH_SOURCE[0]}"
declare real_path
declare real_dir
declare plugin_dir_builtin
declare plugin_dir_custom
declare default_config_dir

# Default settings for plugins to extend
declare -A config

# Flags
declare -A flags=(
	[dryrun]=false
)
declare -A flags_help=(
	[dryrun]="Show the commands that will be used, but don't run them"
)

# Vars
declare -A vars=(
	[file]=""
	[only]=""
)
declare -A vars_help=(
	[file]="Specify a config file to load (after other attempts)"
	[only]="Select only the actions you want to take, comma separated"
)


################################################################################
# MISC HELPERS
################################################################################

# Initialise a few paths etc
function syn_init() {
	real_path="${exec_path}"
	if [[ -L "${exec_path}" ]]; then
		real_path="$(readlink "${exec_path}")"
	fi
	real_dir="$( cd "$( dirname "${real_path}" )" && pwd )"

	plugin_dir_builtin="${real_dir}/plugins"

	if [[ "${SYN_PLUGIN_PATH}" && -d "${SYN_PLUGIN_PATH}" ]]; then
		plugin_dir_custom="${SYN_PLUGIN_PATH}"
	fi

	if [[ "${SYN_DEFAULT_PATH}" && -d "${SYN_DEFAULT_PATH}" ]]; then
		default_config_dir="${SYN_DEFAULT_PATH}"
	fi
}

# Exit with an error and a non-successful exit code
function syn_error() {
	echo "Error: ${1:-"An unknown error has occured"}" 1>&2
	exit 1
}

# Show a prompt for confirmation
function syn_confirm() {
	read -p "$* [y/n]: " response
	if [[ $response =~ ^[Yy].* ]]; then
		return 1
	fi
	return 0
}

# In Array
function in_array() {
	local haystack="${1}[@]"
	local needle=${2}
	for i in ${!haystack}; do
		if [[ ${i} == "${needle}" ]]; then
			return 0
		fi
	done
	return 1
}

# Check if an array key exists
function array_key_exists() {
	eval '[ ${'$2'[$1]+muahaha} ]'
}


################################################################################
# COMMAND WRAPPING
################################################################################

# Wrap SSH commands
function syn_ssh_wrap() {
	# $1 = SSH string
	# $2 = command
	echo "ssh $1 $2"
}

# Wrap Docker commands
function syn_docker_wrap() {
	# $1 = docker container
	# $2 = command
	# $3 = additional flags
	echo "docker exec $3 $1 $2"
}


################################################################################
# INTEGRATED HELP
################################################################################

function syn_render_help_commands() {
	echo "Commands:"
	for c in ${!commands[*]}; do
		echo -e "                    $(${commands[$c]})\r  --$c"
	done
}

function syn_render_help_flags() {
	echo "Flags:"
	for f in ${!flags_help[*]}; do
		echo -e "                    ${flags_help[$f]}\r  --$f"
	done
}

function syn_render_help_vars() {
	echo "Vars:"
	for v in ${!vars_help[*]}; do
		echo -e "                    ${vars_help[$v]}\r  --$v"
	done
}

# Help. Will show specific help from a plugin, or general help with
# lists of environments and plugins
function syn_cmd_help() {
	syn_banner
	if [[ "$1" ]]; then
		if [[ $(set | grep "syn_plugin_${1}_help ()") ]]; then
			echo -e "Showing help for plugin: $1\n";
			eval "syn_plugin_${1}_help"
			exit
		else
			syn_error "Plugin '$1' not found"
		fi
	fi

	echo -e "
A pluggable system to synchronise between environments with builtin plugins
for mysql and rsync.

Usage: syn <SRC> <DST> [COMMANDS/FLAGS/VARS]

Parameters:
  SRC               Must match an environment from the loaded config files
  DST               Must match an environment from the loaded config files

$(syn_render_help_commands)

$(syn_render_help_flags)

$(syn_render_help_vars)

$(syn_cmd_envs)

$(syn_cmd_plugins)

$(syn_cmd_paths)
"
# | less

	exit
}
function syn_cmd_help_help() {
	echo "Show this help (or append a plugin name for specific help)"
}

# Show actions
function syn_cmd_actions() {
	local actions=""
	for a in ${vars[only]}; do
		actions+="\n  $a"
	done
	echo -e "Proposed actions for this sync:${actions}"
}
function syn_cmd_actions_help() {
	echo "Show the actions that are configured for a src, dst, or both"
}

# Show environments
function syn_cmd_envs() {
	# $1 = [true/false] show 'readonly' status
	local envs=""
	for e in ${environments[*]}; do
		envs+="\n  $e"
		if [[ ! "$1" == true && "${config[$e,_allow]}" == false ]]; then
			envs+=" [read only]"
		fi
	done
	echo -e "Loaded Environments:${envs}"
	if [[ ! "${envs}" ]]; then
		echo "  <none>"
	fi
}
function syn_cmd_envs_help() {
	echo "List available environments"
}

# Show paths
function syn_cmd_paths() {
	local tmp_plugin_dir_custom
	local tmp_default_config_dir
	if [[ "${SYN_PLUGIN_PATH}" ]]; then
		if [[ -d "${SYN_PLUGIN_PATH}" ]]; then
			tmp_plugin_dir_custom="${SYN_PLUGIN_PATH}"
		else
			tmp_plugin_dir_custom="${SYN_PLUGIN_PATH} (DOES NOT EXIST)"
		fi
	else
		tmp_plugin_dir_custom="<not set>"
	fi
	if [[ "${SYN_DEFAULT_PATH}" ]]; then
		if [[ -d "${SYN_DEFAULT_PATH}" ]]; then
			tmp_default_config_dir="${SYN_DEFAULT_PATH}"
		else
			tmp_default_config_dir="${SYN_DEFAULT_PATH} (DOES NOT EXIST)"
		fi
	else
		tmp_default_config_dir="<not set>"
	fi
	echo "Custom Paths:"
	echo "  SYN_PLUGIN_PATH: ${tmp_plugin_dir_custom}"
	echo "  SYN_DEFAULT_PATH: ${tmp_default_config_dir}"
}
function syn_cmd_paths_help() {
	echo "List configured paths"
}

# Show plugins
function syn_cmd_plugins() {
	local plgs=""
	for p in ${plugins[*]}; do
		plgs+="\n  $p"
	done
	echo -e "Loaded Plugins:${plgs}"
	if [[ ! "${plgs}" ]]; then
		echo "  <none>"
	fi
}
function syn_cmd_plugins_help() {
	echo "List all available plugins"
}

# Install the thing
function syn_cmd_install() {
	if [[ -L "${BASH_SOURCE[0]}" ]]; then
		syn_error "Syn is already installed as a SymLink."
	fi
	if [[ -e "/usr/local/bin/syn" ]]; then
		syn_error "Syn is already installed to your path."
	fi
	sudo ln -s "$(readlink -f "$0")" "/usr/local/bin/syn";
	echo "You can now run this script simply by typing 'syn'"
}
function syn_cmd_install_help() {
	echo "Installs Syn to your executable path for ease-of-use";
}


################################################################################
# CONFIGURATION FILE LOADING
################################################################################

# Config file loading
function syn_load_configs() {
	config_cnt=0
	for filename in ".syn.global" ".syn" ".syn.local"; do
		local currpath="$PWD"
		while [[ "$currpath" != "/" ]]; do
			if [[ -r "$currpath/$filename" ]]; then
				. "$currpath/$filename"
				(( config_cnt++ ))
				if [[ -z "$local_root" ]]; then
					local_root="$currpath"
				fi
			fi
			currpath=$(cd "$currpath/.." && pwd) || syn_error "Invalid path"
		done
	done
}

# Load specific file (from --file parameter)
function syn_load_config_specific() {
	local old_count=$config_cnt
	if [[ -d "${default_config_dir}" && "${vars[file]}" == "." ]]; then
		# If there is a default location and "." was set as file
		# then we'll use the current directory name as the filename
		# and only check the default location for the config file.
		vars[file]="${default_config_dir}/$(pwd | sed -e 's/.*\///g')"
		for f in "${vars[file]}" "${vars[file]}.syn"; do
			if [[ -f "$f" ]]; then
				. "$f"
				(( config_cnt++ ))
			fi
		done
	elif [[ "${vars[file]}" ]]; then
		for f in "${vars[file]}" "${vars[file]}.syn"; do
			if [[ -f "$f" ]]; then
				# Otherwise we'll check the current dir for the named file
				. "$f"
				(( config_cnt++ ))
			elif [[ -d "${default_config_dir}" && -f "${default_config_dir}/$f" ]]; then
				# And the default location too
				. "${default_config_dir}/$f"
				(( config_cnt++ ))
			fi
		done
	fi

	if [[ "${vars[file]}" ]] && (( "$old_count" == "$config_cnt" )); then
		local err=""
		if [[ -z "${SYN_DEFAULT_PATH}" ]]; then
			err=". Also, SYN_DEFAULT_PATH is not set."
		elif [[ ! -d "${SYN_DEFAULT_PATH}" ]]; then
			err=". Also, SYN_DEFAULT_PATH (${SYN_DEFAULT_PATH}) is not valid."
		fi
		syn_error "Could not find specific config file (${vars[file]})$err"
	fi
}

# Load bundled and external plugins
function syn_load_plugins() {
	plugin_cnt=0
	if [[ -d "$plugin_dir_builtin" ]]; then
		for filename in ${plugin_dir_builtin}/*.synPlugin; do
			. "$filename"
			(( plugin_cnt++ ))
		done
	fi
	if [[ -d "$plugin_dir_custom" ]]; then
		for filename in ${plugin_dir_custom}/*.synPlugin; do
			. "$filename"
			(( plugin_cnt++ ))
		done
	fi
}


################################################################################
# PARSE LOADED DATA
################################################################################

# Show requested actions
function syn_parse_actions() {
	if [[ "${vars[only]}" == "" ]]; then
		declare -A tmp
		local pattern="^[^,]+,([^_][^,]+)"
		for p in "${!config[@]}"; do
			if [[ $p =~ $pattern ]]; then
				: ${tmp[${BASH_REMATCH[1]}]:=${BASH_REMATCH[1]}}
			fi
		done
		vars[only]=${tmp[*]}
	fi
}

# Get the available plugins
function syn_parse_commands() {
	for c in $(compgen -A function syn_cmd_); do
		local cmd="${c//syn_cmd_/}"
		if [[ $c =~ ^syn_cmd_(.+?)_help$ ]]; then
			commands[${BASH_REMATCH[1]}]="$c"
		fi
	done
}

# Get configured environment names
function syn_parse_environments() {
	environments=""
	local pattern="^[^_][^,]+"
	for e in "${!config[@]}"; do
		if [[ $e =~ $pattern ]]; then
			: ${environments[$BASH_REMATCH]:=$BASH_REMATCH}
		fi
	done
}

# Parameter loading
function syn_parse_parameters() {
	# Tried a switch statement, this more efficient
	for (( i=1; i<=$#; i++ )); do
		if [[ ${!i} =~ ^\-\-(.*) ]]; then
			if array_key_exists "${BASH_REMATCH[1]}" flags; then
				flags[${BASH_REMATCH[1]}]=true
			elif array_key_exists "${BASH_REMATCH[1]}" vars; then
				(( i++ ))
				vars[${BASH_REMATCH[1]}]="${!i}"
			elif array_key_exists "${BASH_REMATCH[1]}" commands; then
				cmd="${BASH_REMATCH[1]}"
			fi
		elif [[ ! ${!i} =~ ^- ]]; then
			if [[ ! "$src" ]]; then
				src="${!i}"
			elif [[ ! "$dst" ]]; then
				dst="${!i}"
			else
				syn_error "Unrecognised parameter '${!i}'"
			fi
		else
			syn_error "Unrecognised parameter '${!i}'"
		fi
	done
}

# Get the available plugins
function syn_parse_plugins() {
	plugins=""
	for p in $(compgen -A function syn_plugin_); do
		if [[ ! $p =~ _help$ ]]; then
			plugins="$plugins ${p//syn_plugin_/ }"
		fi
	done
}

# Do we need to show the help?
function syn_check_help_request() {
	if [[ "$#" == 0 || "$cmd" == "help" || ( "$#" == 2 && "${vars[file]}" ) ]]; then
		syn_cmd_help $src || $dst
		exit
	fi
}


################################################################################
# VALIDATION HELPERS
################################################################################

# Require two environments
function syn_validate_allow() {
	# Check if we're pushing to a live environment
	local to=$dst || $src
	if [[ $to =~ (live|prod) || "${config[$to,_allow]}" == "warn" ]]; then
		if syn_confirm "Pushing to this environment could be dangerous, are you sure?"; then
			echo "Aborting"
			exit
		fi
		echo
	fi

	# Check if we're pushing to a disallowed environment
	if [[ "${config[$to,_allow]}" == false ]]; then
		syn_error "Pushing to this environment is not allowed"
		exit
	fi
}

# Require one environment
function syn_validate_require_one_env() {
	# Is the environment set?
	if [[ ! "$src" ]]; then
		syn_error "You must specify an environment"
	fi
	# Is the environment valid?
	if [[ ! "${environments[$src]}" ]]; then
		syn_error "Environment '$src' doesn't exist"
	fi
}

# Require two environments
function syn_validate_require_two_envs() {
	# Are both environments set?
	if [[ ! ( "$src" && "$dst" ) ]]; then
		syn_error "You must specify two environments"
	fi
	# Is the src environment valid?
	if [[ ! "${environments[$src]}" ]]; then
		syn_error "Source environment '$src' doesn't exist"
	fi
	# Is the dst environment valid?
	if [[ ! "${environments[$dst]}" ]]; then
		syn_error "Destination environment '$dst' doesn't exist"
	fi
	if [[ "$src" == "$dst" ]]; then
		syn_error "Souce and destination environments cannot be the same"
	fi
}


################################################################################
# COSMETICS
################################################################################

# The banner
function syn_banner() {
	echo -e "
    _____
   / ____|
  | (___  _   _ _ __     Version: v$_SYN_VERSION
   \___ \| | | | '_ \ 
   ____) | |_| | | | |   Author:  $_SYN_AUTHOR
  |_____/ \__, |_| |_|
           __/ |         Website: $_SYN_WEBSITE
          |___/
"
}


################################################################################
# THE ACTUAL THING
################################################################################

# Do the actual synchronising
function syn_cmd_sync() {
	# Check if we have any configs set
	if (( $config_cnt == 0 )); then
		syn_error "No config files were found"
	fi

	syn_validate_require_two_envs

	syn_validate_allow

	# Show a summary
	echo "Proceeding to sync $(echo -e "${vars[only][@]}" | sed -e 's/,/, /') from $src to $dst"
	if ${flags[dryrun]}; then
		echo -e "\n[DRYRUN]"
	fi

	# Check that all the actions exist
	for x in $(echo -e "${vars[only][@]}" | sed -e 's/,/ /'); do
		if [[ ! $(set | grep "syn_plugin_$x ()") ]]; then
			syn_error "Plugin '$x' not found"
		fi
	done

	# Run all the actions exist
	for x in $(echo -e "${vars[only][@]}" | sed -e 's/,/ /'); do
		echo -e "\nRunning plugin: $x"
		eval "syn_plugin_${x}"
	done
}


# Main processing function
function main() {
	# Load and parse everything
	syn_init
	syn_load_configs
	syn_load_plugins
	syn_parse_commands
	syn_parse_plugins
	syn_parse_parameters "$@"
	syn_load_config_specific
	syn_parse_environments
	syn_parse_actions
	syn_check_help_request "$@"

	# Do the chosen command8
	eval "syn_cmd_${cmd}"

	# Let's get out of here
	exit
}


main "$@"
