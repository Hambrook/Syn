#!/bin/bash

# SYN
#
# Easily synchronise website content (database and asset files) between environments
#
# @version    0.2
# @author     Rick Hambrook <rick@rickhambrook.com>
# @copyright  Copyright (c) 2016 Rick Hambrook
# @license    http://opensource.org/licenses/GPL-3.0  GNU Public License


# TODO
# [X] Add rsync ssh proxy (-e "ssh -A root@proxy ssh")
# [X] Fix rsync flags not being applied
# [X] Update plugin docs with new naming scheme, and flag/var support
# [ ] Use centralised config file for paths and setting, docker/docker-machine (location optionally configurable via env var)
# [ ] Add boot2docker support
# [ ] Add pre-flight validation checks for each plugin
# [ ] Add core validation functions for use by plugins
# [ ]   - ssh connection works (maybe, might cause too many connections)
# [ ]   - docker container exists
# [ ]   - docker container on ssh host is accessible and exists
# [ ] Add timing report
# [ ] Add colours to output
# [ ] Check all quotes and escape sequences
# [ ] See if there is an easier to way merge defaults with supplied values
# [ ] RSYNC: Find a better way to define file paths
# [ ] Maybe load a single location as global config, maybe ~/.syn/config
# [ ] Add shorthand parameters?
# [ ] Enable notify-send?
# [ ] Enable dumping of sample config from each plugin?
# [ ] Clean up logic around mysql only/skip/stru
# [ ] RSYNC: Add excludes list
# [X] Enable specifying a file to load (--file)
# [X]   - Search in specified location for RSYNC (eg store all syn RSYNC in one location, specified by an env var)
# [ ] Add more error checking
# [X]   - Check that both environments exist
# [X]   - Require two environments
# [X]   - Check a plugin exists before attempting to use it
# [X]   - Only sync file locations with matching keys
# [X] RSYNC: add manual and auto root
# [X] Rename builtin plugins to "mysql" and "rsync" instead of "db" and "files"
# [X] Add optional docker layer
# [X] Move flags, vars, and commands to being dynamic with dynamic help so that plugins can add them
# [X] Add default path for use with the --file parameter
# [X] Automatically list actions to be taken for each sync
# [X] Enable listing of environments (--envs)?
# [X] Enable listing of plugins (--plugins)?
# [X] Load from multiple RSYNC, eg in repo, locally and globally
# [X] Support loading extra action plugins from an environmental path
# [X] Help system
# [X]   - Dynamically list action plugins
# [X]   - Dynamically list action plugin help
# [X] MySQL: Allow skipping of tables
# [X] MySQL: Allow structure-only table copies
# [X] MySQL: Allow toggling of using SSH for MySQL connections
# [X] Prompt/warn before pushing to prod/live or if _allow is set to "warn"
# [X] Disallow if _allow is set to false

_SYN_VERSION=0.2
_SYN_AUTHOR="Rick Hambrook"
_SYN_WEBSITE="https://www.rickhambrook.com"

# Initial settings
declare cmd="sync"
declare src
declare dst
declare config_cnt
declare plugin_cnt
declare local_root=""
declare -A actions
declare -A commands
declare -A environments
declare -A plugins
declare exec_path="${BASH_SOURCE[0]}"
declare real_path
declare real_dir
declare plugin_dir_builtin
declare plugin_dir_custom
declare default_config_dir
declare colour_enabled=true

# Default settings for plugins to extend
declare -A config

# Flags
declare -A flags=(
	[dryrun]=false
	[force]=false
)
declare -A flags_help=(
	[dryrun]="Show the commands that will be used, but don't run them"
	[force]="Push to live/prod/'warn' without confirmation prompt (if applicable)"
)

# Vars
declare -A vars=(
	[file]=""
	[only]=""
)
declare -A vars_help=(
	[file]="Specify a config file to load (after other attempts)"
	[only]="Select only the actions you want to take, comma separated"
)

# Formatting vars
declare -A formatting=(
	# Formatting
	[normal]=0
	[reset]=0
	[bold]=1
	[dim]=2
	[underline]=4
	[ul]=4
	[blink]=5
	[reverse]=7
	[hidden]=8
	# Reset formatting
	[r_bold]=21
	[r_dim]=22
	[r_underline]=24
	[r_ul]=24
	[r_blink]=25
	[r_reverse]=27
	[r_hidden]=28
	# Foreground colours
	[default]=39
	[black]=30
	[red]=31
	[green]=32
	[yellow]=33
	[blue]=34
	[magenta]=35
	[cyan]=36
	[lightgray]=37
	[darkgray]=90
	[lightred]=91
	[lightgreen]=92
	[lightyellow]=93
	[lightblue]=94
	[lightmagenta]=95
	[lightcyan]=96
	[white]=97
	# Background colours
	[bg_default]=49
	[bg_black]=40
	[bg_red]=41
	[bg_green]=42
	[bg_yellow]=43
	[bg_blue]=44
	[bg_magenta]=45
	[bg_cyan]=46
	[bg_lightgray]=47
	[bg_darkgray]=100
	[bg_lightred]=101
	[bg_lightgreen]=102
	[bg_lightyellow]=103
	[bg_lightblue]=104
	[bg_lightmagenta]=105
	[bg_lightcyan]=106
	[bg_white]=107
)


################################################################################
# MISC HELPERS
################################################################################

# Get a formatting string
function _() {
	if [[ ! $# || $colour_enabled == false ]]; then
		return
	fi

	output=""
	for var in "$@"; do
		if array_key_exists $var formatting; then
			if [[ $output != "" ]]; then
				output="${output};"
			fi
			output="${output}${formatting[${var}]}"
		fi
	done

	printf "\e[${output}m"
}

# Initialise a few paths etc
function syn_init() {
	real_path="${exec_path}"
	if [[ -L "${exec_path}" ]]; then
		real_path="$(readlink "${exec_path}")"
	fi
	real_dir="$( cd "$( dirname "${real_path}" )" && pwd )"

	plugin_dir_builtin="${real_dir}/plugins"

	if [[ "${SYN_PLUGIN_PATH}" && -d "${SYN_PLUGIN_PATH}" ]]; then
		plugin_dir_custom="${SYN_PLUGIN_PATH}"
	fi

	if [[ "${SYN_DEFAULT_PATH}" && -d "${SYN_DEFAULT_PATH}" ]]; then
		default_config_dir="${SYN_DEFAULT_PATH}"
	fi
}

# Exit with an error and a non-successful exit code
function syn_error() {
	printf "$(_ red)Error: %s\n" "${1:-"An unknown error has occured"}$(_ reset)" 1>&2
	exit 1
}

# Show a prompt for confirmation
function syn_confirm() {
	# $1 = Confirmation message
	# $2 = default (y/true/n/false)

	case $2 in
		1|y|Y|true)
			prompt="Y/n"
			default=1
			;;
		0|n|N|false)
			prompt="y/N"
			default=0
			;;
		*) 
			prompt="y/n"
			default=0
			;;
	esac

	read -p "$1 [$prompt]:$3 " response
	if [[ $response =~ ^[Yy].* ]]; then
		return 1
	fi
	if [[ $response = "" ]]; then
		return $default
	fi
	return 0
}

# In Array
function in_array() {
	local array="$1[@]"
	local seeking=$2
	local in=1
	for element in "${!array}"; do
		if [[ $element == $seeking ]]; then
			in=0
			break
		fi
	done
	return $in
}

# Check if an array key exists
function array_key_exists() {
	eval '[ ${'$2'[$1]+muahaha} ]'
}

# Check if a plugin exists
function syn_validate_plugin() {
	if [[ $(set | grep "syn_plugin_$1 ()") ]]; then
		echo 1;
	else
		echo "";
	fi
}

# Get the actual plugin name from a potentially aliased (fuzzy) name... eg. rsync.webdirs
function syn_get_plugin_name_from_fuzzy() {
	printf "$1" | sed -e 's/[(\.].*//g'
}


################################################################################
# COMMAND WRAPPING
################################################################################

# Wrap SSH commands
function syn_ssh_wrap() {
	# $1 = SSH string
	# $2 = command
	printf "ssh %s %s" "$1" "$2"
}

# Wrap Docker commands
function syn_docker_wrap() {
	# $1 = docker container
	# $2 = command
	# $3 = additional flags
	printf "docker exec %s %s %s" "$3" "$1" "$2"
}


################################################################################
# INTEGRATED HELP
################################################################################

function syn_render_help_commands() {
	printf "$(_ bold)Commands:$(_ r_bold)\n"
	for c in ${!commands[*]}; do
		printf "  --%-15s %s\n" "$c" "$(${commands[$c]})"
	done
}

function syn_render_help_flags() {
	printf "$(_ bold)Flags:$(_ r_bold)\n"
	for f in ${!flags_help[*]}; do
		printf "  --%-15s %s\n" "$f" "${flags_help[$f]}"
	done
}

function syn_render_help_vars() {
	printf "$(_ bold)Vars:$(_ r_bold)\n"
	for v in ${!vars_help[*]}; do
		printf "  --%-15s %s\n" "$v" "${vars_help[$v]}"
	done
}

# Help. Will show specific help from a plugin, or general help with
# lists of environments and plugins
function syn_cmd_help() {
	syn_banner
	if [[ "$1" ]]; then
		if [[ $(set | grep "syn_plugin_${1}_help ()") ]]; then
			printf "Showing help for plugin: %s\n\n" "$1"
			eval "syn_plugin_${1}_help"
			exit
		else
			syn_error "Plugin '$1' not found"
		fi
	fi

	printf "
A pluggable system to synchronise between environments with builtin plugins
for mysql and rsync.

Usage: syn <SRC> <DST> [COMMANDS/FLAGS/VARS]

$(_ bold)Parameters:$(_ r_bold)
  SRC               Must match an environment from the loaded config files
  DST               Must match an environment from the loaded config files

$(syn_render_help_commands)

$(syn_render_help_flags)

$(syn_render_help_vars)

$(syn_cmd_envs)

$(syn_cmd_plugins)

$(syn_cmd_paths)
"
# | less

	exit
}
function syn_cmd_help_help() {
	printf "Show this help (or append a plugin name for specific help)"
}

# Show actions
function syn_cmd_actions() {
	local actions=""
	for a in ${vars[only]}; do
		actions+="\n  $a"
	done
	if [[ ! "${actions}" ]]; then
		actions="\n  <none>"
	fi
	printf "Proposed actions for this sync:${actions}\n"
}
function syn_cmd_actions_help() {
	printf "Show the actions that are configured for a src, dst, or both"
}

# Show environments
function syn_cmd_envs() {
	# $1 = [true/false] show 'readonly' status
	local envs=""
	for e in ${environments[*]}; do
		envs+="\n  $e"
		if [[ ! "$1" == true && "${config[$e/_allow]}" == false ]]; then
			envs+=" [read only]"
		fi
	done
	if [[ ! "${envs}" ]]; then
		envs="\n  <none>"
	fi
	printf "$(_ bold)Loaded Environments:$(_ r_bold)${envs}\n"
}
function syn_cmd_envs_help() {
	printf "List available environments"
}

# Show paths
function syn_cmd_paths() {
	local tmp_plugin_dir_custom
	local tmp_default_config_dir
	if [[ "${SYN_PLUGIN_PATH}" ]]; then
		if [[ -d "${SYN_PLUGIN_PATH}" ]]; then
			tmp_plugin_dir_custom="${SYN_PLUGIN_PATH}"
		else
			tmp_plugin_dir_custom="${SYN_PLUGIN_PATH} (DOES NOT EXIST)"
		fi
	else
		tmp_plugin_dir_custom="<not set>"
	fi
	if [[ "${SYN_DEFAULT_PATH}" ]]; then
		if [[ -d "${SYN_DEFAULT_PATH}" ]]; then
			tmp_default_config_dir="${SYN_DEFAULT_PATH}"
		else
			tmp_default_config_dir="${SYN_DEFAULT_PATH} (DOES NOT EXIST)"
		fi
	else
		tmp_default_config_dir="<not set>"
	fi
	printf "$(_ bold)Custom Paths:$(_ r_bold)\n"
	printf "  SYN_PLUGIN_PATH: ${tmp_plugin_dir_custom}\n"
	printf "  SYN_DEFAULT_PATH: ${tmp_default_config_dir}\n"
}
function syn_cmd_paths_help() {
	printf "List configured paths"
}

# Show plugins
function syn_cmd_plugins() {
	local plgs=""
	for p in ${plugins[*]}; do
		plgs+="\n  $p"
	done
	if [[ ! "${plgs}" ]]; then
		plgs="\n  <none>"
	fi
	printf "$(_ bold)Loaded Plugins:$(_ r_bold)${plgs}\n"
}
function syn_cmd_plugins_help() {
	printf "List all available plugins"
}

# Install the thing
function syn_cmd_install() {
	if [[ -L "${BASH_SOURCE[0]}" ]]; then
		syn_error "Syn is already installed as a SymLink."
	fi
	if [[ -e "/usr/local/bin/syn" ]]; then
		syn_error "Syn is already installed to your path."
	fi
	sudo ln -s "$(readlink -f "$0")" "/usr/local/bin/syn"
	printf "You can now run this script simply by typing 'syn'\n"
}
function syn_cmd_install_help() {
	printf "Installs Syn to your executable path for ease-of-use\n"
}


################################################################################
# CONFIGURATION FILE LOADING
################################################################################

# Config file loading
function syn_load_configs() {
	config_cnt=0
	for filename in ".syn.global" ".syn" ".syn.local"; do
		local currpath="$PWD"
		while [[ "$currpath" != "/" ]]; do
			if [[ -r "$currpath/$filename" ]]; then
				. "$currpath/$filename"
				(( config_cnt++ ))
				if [[ -z "$local_root" ]]; then
					local_root="$currpath"
				fi
			fi
			currpath=$(cd "$currpath/.." && pwd) || syn_error "Invalid path"
		done
	done
}

# Load specific file (from --file parameter)
function syn_load_config_specific() {
	local old_count=$config_cnt
	if [[ -d "${default_config_dir}" && "${vars[file]}" == "." ]]; then
		# If there is a default location and "." was set as file
		# then we'll use the current directory name as the filename
		# and only check the default location for the config file.
		vars[file]="${default_config_dir}/$(pwd | sed -e 's/.*\///g')"
		for f in "${vars[file]}" "${vars[file]}.syn"; do
			if [[ -f "$f" ]]; then
				. "$f"
				(( config_cnt++ ))
			fi
		done
	elif [[ "${vars[file]}" ]]; then
		for f in "${vars[file]}" "${vars[file]}.syn"; do
			if [[ -f "$f" ]]; then
				# Otherwise we'll check the current dir for the named file
				. "$f"
				(( config_cnt++ ))
			elif [[ -d "${default_config_dir}" && -f "${default_config_dir}/$f" ]]; then
				# And the default location too
				. "${default_config_dir}/$f"
				(( config_cnt++ ))
			fi
		done
	fi

	if [[ "${vars[file]}" ]] && (( "$old_count" == "$config_cnt" )); then
		local err=""
		if [[ -z "${SYN_DEFAULT_PATH}" ]]; then
			err=". Also, SYN_DEFAULT_PATH is not set."
		elif [[ ! -d "${SYN_DEFAULT_PATH}" ]]; then
			err=". Also, SYN_DEFAULT_PATH (${SYN_DEFAULT_PATH}) is not valid."
		fi
		syn_error "Could not find specific config file (${vars[file]})$err"
	fi
}

# Load bundled and external plugins
function syn_load_plugins() {
	plugin_cnt=0
	if [[ -d "$plugin_dir_builtin" ]]; then
		for filename in ${plugin_dir_builtin}/*.synPlugin; do
			. "$filename"
			(( plugin_cnt++ ))
		done
	fi
	if [[ -d "$plugin_dir_custom" ]]; then
		for filename in ${plugin_dir_custom}/*.synPlugin; do
			. "$filename"
			(( plugin_cnt++ ))
		done
	fi
}


################################################################################
# PARSE LOADED DATA
################################################################################

# Show requested actions
function syn_parse_actions() {
	if [[ "${vars[only]}" == "" ]]; then
		declare -A tmp
		local pattern="^[^/]+/([^_][^/]+)"
		for p in "${!config[@]}"; do
			if [[ $p =~ $pattern ]]; then
				: ${tmp[${BASH_REMATCH[1]}]:=${BASH_REMATCH[1]}}
			fi
		done
		vars[only]=${tmp[*]}
	fi
}

# Get the available plugins
function syn_parse_commands() {
	for c in $(compgen -A function syn_cmd_); do
		local cmd="${c//syn_cmd_/}"
		if [[ $c =~ ^syn_cmd_(.+?)_help$ ]]; then
			commands[${BASH_REMATCH[1]}]="$c"
		fi
	done
}

# Get configured environment names
function syn_parse_environments() {
	environments=""
	local pattern="^[^_][^/]+"
	for e in "${!config[@]}"; do
		if [[ $e =~ $pattern ]]; then
			: ${environments[$BASH_REMATCH]:=$BASH_REMATCH}
		fi
	done
}

# Parameter loading
function syn_parse_parameters() {
	# Tried a switch statement, this more efficient
	for (( i=1; i<=$#; i++ )); do
		# Strip leading dashes and test for flags, commands and vars
		if [[ ${!i} =~ ^\-\-(.*) ]]; then
			# Is it a flag, eg "--dryrun"?
			if array_key_exists "${BASH_REMATCH[1]}" flags; then
				flags[${BASH_REMATCH[1]}]=true
			# Is it a command, eg "--help"?
			elif array_key_exists "${BASH_REMATCH[1]}" commands; then
				cmd="${BASH_REMATCH[1]}"
			# Is it a space-separated var, eg "--only rsync"?
			elif array_key_exists "${BASH_REMATCH[1]}" vars; then
				(( i++ ))
				vars[${BASH_REMATCH[1]}]="${!i}"
			# Or even an equals separated var, eg "--only=rsync"?
			elif [[ "${BASH_REMATCH[1]}" == *"="* ]]; then
				local varinfo=(${BASH_REMATCH[1]//=/ })
				if array_key_exists "${varinfo[0]}" vars; then
					vars[${varinfo[0]}]="${varinfo[1]}"
				fi
			fi
		# If there are no leading dashes then it must be an environment
		elif [[ ! ${!i} =~ ^- ]]; then
			if [[ ! "$src" ]]; then
				src="${!i}"
			elif [[ ! "$dst" ]]; then
				dst="${!i}"
			else
				syn_error "Unrecognised parameter '${!i}'"
			fi
		else
			syn_error "Unrecognised parameter '${!i}'"
		fi
	done
}

# Get the available plugins
function syn_parse_plugins() {
	plugins=""
	for p in $(compgen -A function syn_plugin_); do
		if [[ ! $p =~ _help$ ]]; then
			plugins="$plugins ${p//syn_plugin_/ }"
		fi
	done
}

# Do we need to show the help?
function syn_check_help_request() {
	if [[ "$#" == 0 || "$cmd" == "help" || ( "$#" == 2 && "${vars[file]}" ) ]]; then
		syn_cmd_help $src || $dst
		exit
	fi
}


################################################################################
# VALIDATION HELPERS
################################################################################

# Require two environments
function syn_validate_allow() {
	# Check if we're pushing to a live environment
	local to=$dst || $src

	# Check if we're pushing to a disallowed environment
	if [[ "${config[$to/_allow]}" == false ]]; then
		syn_error "Pushing to this environment is not allowed"
		exit
	fi

	if [[ $to =~ (live|prod) || "${config[$to/_allow]}" == "warn" ]]; then
		if ${flags[force]}; then
			printf "$(_ bg_yellow)\n\tWARNING: Forcing override of dangerous deployment warning\n$(_ reset)\n"
			#printf "$(_ yellow bold)WARNING: Forcing override of dangerous deployment warning$(_ reset)\n"
		elif syn_confirm "$(_ yellow)Pushing to this environment could be dangerous, are you sure?" false "$(_ reset)"; then
			printf "Aborting\n"
			exit
		fi
		printf "\n"
	fi
}

# Require one environment
function syn_validate_require_one_env() {
	# Is the environment set?
	if [[ ! "$src" ]]; then
		syn_error "You must specify an environment"
	fi
	# Is the environment valid?
	if [[ ! "${environments[$src]}" ]]; then
		syn_error "Environment '$src' doesn't exist"
	fi
}

# Require two environments
function syn_validate_require_two_envs() {
	# Are both environments set?
	if [[ ! ( "$src" && "$dst" ) ]]; then
		syn_error "You must specify two environments"
	fi
	# Is the src environment valid?
	if [[ ! "${environments[$src]}" ]]; then
		syn_error "Source environment '$src' doesn't exist"
	fi
	# Is the dst environment valid?
	if [[ ! "${environments[$dst]}" ]]; then
		syn_error "Destination environment '$dst' doesn't exist"
	fi
	if [[ "$src" == "$dst" ]]; then
		syn_error "Souce and destination environments cannot be the same"
	fi
}


################################################################################
# COSMETICS
################################################################################

# The banner
function syn_banner() {
	printf "$(_ lightgreen bold)
    _____
   / ____|
  | (___  _   _ _ __     $(_ green r_bold)Version: v%s$(_ lightgreen bold)
   \___ \| | | | '_ \ 
   ____) | |_| | | | |   $(_ green r_bold)Author:  %s$(_ lightgreen bold)
  |_____/ \__, |_| |_|
           __/ |         $(_ green r_bold)Website: %s$(_ lightgreen bold)
          |___/

$(_ reset)" "$_SYN_VERSION" "$_SYN_AUTHOR" "$_SYN_WEBSITE"
}


################################################################################
# THE ACTUAL THING
################################################################################

# Do the actual synchronising
function syn_cmd_sync() {
	# Check if we have any configs set
	if (( $config_cnt == 0 )); then
		syn_error "No config files were found"
	fi

	syn_validate_require_two_envs

	syn_validate_allow

	# Show a summary
	printf "Proceeding to sync %s from $(_ bold)%s$(_ reset) to $(_ bold)%s$(_ reset)\n" "$(printf "${vars[only][@]}" | sed -e 's/,/, /')" "$src" "$dst"
	if ${flags[dryrun]}; then
		printf "\n[DRYRUN]\n"
	fi

	# Check that all the actions exist
	for x in $(printf "${vars[only][@]}" | sed -e 's/,/ /'); do
		local p=$(syn_get_plugin_name_from_fuzzy $x)
		if [[ ! $(syn_validate_plugin $p) ]]; then
			syn_error "Plugin '$p' not found"
		fi
	done

	# Run all the actions exist
	for x in $(printf "${vars[only][@]}" | sed -e 's/,/ /'); do
		printf "\n$(_ green bold)Running plugin: %s$(_ reset)\n" "$x"
		local p=$(syn_get_plugin_name_from_fuzzy $x)
		eval "syn_plugin_${p} \"${x}\""
	done
}


# Main processing function
function main() {
	# Load and parse everything
	syn_init
	syn_load_configs
	syn_load_plugins
	syn_parse_commands
	syn_parse_plugins
	syn_parse_parameters "$@"
	syn_load_config_specific
	syn_parse_environments
	syn_parse_actions
	syn_check_help_request "$@"

	# Do the chosen command
	eval "syn_cmd_${cmd}"

	# Let's get out of here
	exit
}


main "$@"
